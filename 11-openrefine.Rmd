# Data Cleaning Part III: Open Refine

Gather 'round kids and let me tell you a tale about your author. In college, your author (Matt Waite) got involved in a project where he mapped crime in the city, looking specifically in the neighborhoods surrounding campus. This was in the mid 1990s. Computers were under powered. Tools were pretty primitive. I was given a database of nearly 50,000 calls for service. 

And then I learned that addresses were not stored in a standard way. However the officer wrote it down, that's how it was recorded. 

What did that mean? 

It meant the Lincoln (Nebraska) Police Department came up with dozens of ways to say a single place. And since the mapping software needed the addressed to be in a specific form, I had to fix them. For example, I will go to my grave knowing that Lincoln High School's street address is 2229 J Street. Police officers wrote down LHS, L.H.S., Lincoln HS, Lincoln H.S., LHS (J Street), 2229 J, 2229 J ST, St., Street and on and on and on. That one was relatively easy. The local convenience store chain, with 8 locations around the city, was harder. I had to use the patrol district to locate them. 

It took me four months to clean up more than 30,000 unique addresses and map them. 

I tell you this because if I had Open Refine, it would have taken me a week, not four months. 

Every time I talk about Open Refine, I remember this, and I get mad. 

Fortunately (unfortunately?) several columns in the PPP loan data we're working with are flawed in exactly the same way. There are dozens of variations on just "Baltimore".    

We're going to explore two ways into Open Refine: Through R, and through Open Refine itself.

## Refinr, Open Refine in R

What is Open Refine? 

Open Refine is a software program that has tools -- algorithms -- that find small differences in text and helps you fix them quickly. How Open Refine finds those small differences is through something called clustering. The algorithms behind clustering are not exclusive to Open Refine, so they can be used elsewhere. 

Enter `refinr`, a package that contains the same clustering algorithms as Open Refine but all within R. Go ahead and install it if you haven't already by opening the console and running `install.packages("refinr")`. Then we can load libraries as we do.

```{r}
library(tidyverse)
library(refinr)
library(janitor)
```

Let's load our full Maryland PPP loans data. 

```{r}
md_loans <- read_rds("data/ppp_loan_data/processed/md/ppp_loans_md.rmd")
```

Now let's try and group and count the number of loans by city. To make it a bit more managable, let's use another string function from `stringr` and filter for cities that start with the uppercase "A" or lowercase "a" using the function `str_detect()` with a regular expression.  The filter function in the codeblock below says: look in the city column, and pluck out any value that starts with (the "^" symbol means "starts with") a lowercase "a" OR (the vertical "|", called a pipe, means OR) an uppercase "A".  

```{r}
md_loans %>% 
  group_by(city) %>% 
  summarise(
    count=n()
  ) %>%
  filter(str_detect(city, "^a|^A")) %>%
  arrange(city)
```

By using the OpenRefine package for R, `refinr`, our hope is that it can identify and standardize the data. 

The first merging technique that's part of the `refinr` package we'll try is the `key_collision_merge`. 

The key collision merge function takes each string and extracts the key parts of it. It then puts every key in a bin based on the keys matching. 

One rule you should follow when using this is: **do not overwrite your original fields**. Always work on a copy. If you overwrite your original field, how will you know if it did the right thing? How can you compare it to your original data? To follow this, I'm going to mutate a new field called clean_city and put the results of key collision merge there. 

```{r}
cleaned_md_loans <- md_loans %>% 
  mutate(city_clean=key_collision_merge(city)) %>%
  select(id:city, city_clean, everything())

cleaned_md_loans

```
To examine changes `refinr` made, let's examine the changes it made to cities that start with the letter "A". 

```{r}
cleaned_md_loans %>% 
  group_by(city_clean, city) %>% 
  summarise(
    count=n()
  ) %>%
  filter(str_detect(city, "^a|^A")) %>%
  arrange(city)
```
It got a bunch of things right.  It merged three variations of "Aberdeen" -- "aberdeen","Aberdeen" and "ABERDEEN" -- and it didn't merge it with "Aberdeen Proving Ground", which are likely two distinct things. But it wasn't smart enough to convert "Abereen". 

It also merged "Annapolis" and "ANNAPOLIS" under "Annapolis", and was smart enough not to merge it with "Annapolis Junction", which is not the same city. But it wasn't smart enough to merge "Annapoils" or "Annalpolis".

There's another merging algorithim that's part of refinr that works a bit differently, called `n_gram_merge()`.  Let's try applying that one. 

```{r}
cleaned_md_loans <- md_loans %>% 
  mutate(city_clean=n_gram_merge(city)) %>%
  select(id:city, city_clean, everything()) 

cleaned_md_loans

```

To examine changes `refinr` made with this algorithm, let's again look at cities that start with the letter "A". Examining Aberdeen and Annapolis, we see there wasn't a substantial change. 

```{r}
cleaned_md_loans %>% 
  group_by(city_clean, city) %>% 
  summarise(
    count=n()
  ) %>%
  filter(str_detect(city, "^a|^A")) %>%
  arrange(city)
```
Let's upload the data to the interactive version of OpenRefine, which really shines at this task. 

## Manually cleaning data with Open Refine

Open Refine is free software. [You should download and install it](https://openrefine.org/). Refinr is great for quick things on smaller datasets that you can check to make sure it's not up to any mischief. 

For bigger datasets, Open Refine is the way to go. And it has a lot more tools than refinr does (by design).

After you install it, run it. Open Refine works in the browser, and the app spins up a small web server visible only on your computer to interact with it. A browser will pop up automatically. 

You first have to import your data into a project. 

```{r, echo=FALSE}
knitr::include_graphics(rep("images/open1.png"))
```

After your data is loaded into the app, you'll get a screen to look over what the data looks like. On the top right corner, you'll see a button to create the project.

```{r, echo=FALSE}
knitr::include_graphics(rep("images/open2.png"))
```

The real power in Open Refine is in faceting. In our case, we're specifically going to use text faceting. Next to the OFFENSE ARREST DESC header, click the down arrow, then facet, then text facet.

```{r, echo=FALSE}
knitr::include_graphics(rep("images/open3.png"))
```

After that, a new box will appear on the left. It tells us how many unique offenses are there: 4,082. And, there's a button on the right of the box that says Cluster. Click that.

```{r, echo=FALSE}
knitr::include_graphics(rep("images/open4.png"))
```

The default clustering algorithm used is key collision, using the fingerprint function. This is the same method we used with Sheridan County above. 

At the top, you'll see which method was used, and how many clusters that algorithm identified. Then, below that, you can see what those clusters are. Then, using human judgement, you can say if you agree with the cluster. If you do, click the  merge checkbox. When it merges, the new result will be what it says  in New Cell Value. Most often, that's the row with the most common result. 

```{r, echo=FALSE}
knitr::include_graphics(rep("images/open6.png"))
```

Now begins the fun part: You have to look at all 303 clusters found and decide if they are indeed valid. The key collision method is very good, and very conservative. You'll find that most of them are usually valid.

When you're done, click Merge Selected and Re-Cluster.

If any new clusters come up, evaluate them. Repeat until either no clusters come up or the clusters that do come up are ones you reject.

Now. Try a new method. Rinse and repeat. You'll keep doing this, and if the dataset is reasonably clean, you'll find the end.

If it's not, it'll go on forever. 

```{r, echo=FALSE}
knitr::include_graphics(rep("images/open7.png"))
```
```{r, echo=FALSE}
knitr::include_graphics(rep("images/open8.png"))
```

A question for all data analysts -- if the dataset is bad enough, can it ever be cleaned?

There's no good answer. You have to find it yourself.
